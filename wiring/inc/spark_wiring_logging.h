/*
 * Copyright (c) 2016 Particle Industries, Inc.  All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef SPARK_WIRING_LOGGING_H
#define SPARK_WIRING_LOGGING_H

#include <initializer_list>
#include <vector>
#include <cstring>
#include <cstdarg>

#include "logging.h"

#include "spark_wiring_print.h"

namespace spark {

/*!
    \brief Log handler.

    This class can be subclassed to implement custom log handlers. Log handlers act as "sinks" for
    logging output generated by system and application modules and may have individual filtering
    settings.

    The library also provides several built-in handlers, such as \ref spark::SerialLogHandler and
    \ref spark::Serial1LogHandler.
*/
class LogHandler {
public:
    /*!
        \brief Category filter.

        Describes minimal logging level allowed for category.
    */
    typedef std::pair<const char*, LogLevel> Filter;
    /*!
        \brief List of category filters.
    */
    typedef std::initializer_list<Filter> Filters;

    /*!
        \brief Constructor.
        \param level Default logging level.
        \param filters Category filters.
    */
    explicit LogHandler(LogLevel level = LOG_LEVEL_INFO, const Filters &filters = {});
    /*!
        \brief Destructor.
    */
    virtual ~LogHandler();
    /*!
        \brief Returns default logging level.
    */
    LogLevel defaultLevel() const;
    /*!
        \brief Returns logging level for specified category.
        \param category Category name.
    */
    LogLevel categoryLevel(const char *category) const;
    /*!
        \brief Returns level name.
        \param level Logging level.
    */
    static const char* levelName(LogLevel level);

    // These methods are called by the LogManager instance
    void message(const char *msg, LogLevel level, const char *category, const LogAttributes &attr);
    void write(const char *data, size_t size, LogLevel level, const char *category);

protected:
    /*!
        \brief Processes log message.
        \param msg Text message.
        \param level Logging level.
        \param category Category name (can be null).
        \param attr Message attributes.

        Default implementation generates messages in the following format:
        `<timestamp>: [category]: [file]:[line], [function]: <level>: <message>`.

        Resulting string is then written to output stream via \ref write(const char*, size_t) method.
    */
    virtual void logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr);
    /*!
        \brief Writes character buffer to output stream.
        \param data Buffer.
        \param size Buffer size.

        Default implementation does nothing.
    */
    virtual void write(const char *data, size_t size);
    /*!
        \brief Writes string to output stream.
        \param str String.

        This method is equivalent to `write(str, strlen(str))`.
    */
    void write(const char *str);

private:
    struct FilterData;

    std::vector<FilterData> filters_;
    LogLevel level_;
};

/*!
    \brief Stream-based log handler.

    Adapter class allowing to use existent stream objects as destination for logging output.
*/
class StreamLogHandler: public LogHandler {
public:
    /*!
        \brief Output stream type.
    */
    typedef Print Stream;

    /*!
        \brief Constructor.
        \param stream Output stream.
        \param level Default logging level.
        \param filters Category filters.
    */
    explicit StreamLogHandler(Stream &stream, LogLevel level = LOG_LEVEL_INFO, const Filters &filters = {});
    /*!
        \brief Returns output stream.
    */
    Stream* stream() const;

protected:
    /*!
        \brief Writes character buffer to output stream.
        \param data Buffer.
        \param size Buffer size.

        This method is equivalent to `stream()->write((const uint8_t*)data, size)`.
    */
    virtual void write(const char *data, size_t size) override;

private:
    Stream *stream_;
};

/*!
    \brief Logger.

    Primary interface for application logging. Most logging operations, except configuration, are
    done through this class.

    The library also declares default logger instance accessible as global \ref Log variable.
*/
class Logger {
public:
    /*!
        \brief Default logging level.
    */
    static const LogLevel DEFAULT_LEVEL = LOG_LEVEL_INFO;

    /*!
        \brief Constructor.
        \param name Category name.

        Default-constructed logger uses category name specified at module level (typically, "app").
    */
    explicit Logger(const char *name = LOG_MODULE_CATEGORY);
    /*!
        \brief Generates trace message.
        \param fmt Format string.
    */
    void trace(const char *fmt, ...) const __attribute__((format(printf, 2, 3))); // First argument is implicit 'this'
    /*!
        \brief Generates info message.
        \param fmt Format string.
    */
    void info(const char *fmt, ...) const __attribute__((format(printf, 2, 3)));
    /*!
        \brief Generates warning message.
        \param fmt Format string.
    */
    void warn(const char *fmt, ...) const __attribute__((format(printf, 2, 3)));
    /*!
        \brief Generates error message.
        \param fmt Format string.
    */
    void error(const char *fmt, ...) const __attribute__((format(printf, 2, 3)));
    /*!
        \brief Writes formatted string to log.
        \param fmt Format string.

        This method uses default logging level (\ref DEFAULT_LEVEL).
    */
    void printf(const char *fmt, ...) const __attribute__((format(printf, 2, 3)));
    /*!
        \brief Writes formatted string to log.
        \param level Logging level.
        \param fmt Format string.
    */
    void printf(LogLevel level, const char *fmt, ...) const __attribute__((format(printf, 3, 4)));
    /*!
        \brief Writes string to log.
        \param str String.

        This method uses default logging level (\ref DEFAULT_LEVEL).
    */
    void print(const char *str) const;
    /*!
        \brief Writes string to log.
        \param level Logging level.
        \param str String.
    */
    void print(LogLevel level, const char *str) const;
    /*!
        \brief Writes character buffer to log.
        \param data Buffer.
        \param size Buffer size.

        This method uses default logging level (\ref DEFAULT_LEVEL).
    */
    void write(const char *data, size_t size) const;
    /*!
        \brief Writes character buffer to log.
        \param level Logging level.
        \param data Buffer.
        \param size Buffer size.
    */
    void write(LogLevel level, const char *data, size_t size) const;
    /*!
        \brief Encodes data buffer in hex and writes resulting string to log.
        \param data Buffer.
        \param size Buffer size.

        This method uses default logging level (\ref DEFAULT_LEVEL).
    */
    void dump(const void *data, size_t size) const;
    /*!
        \brief Encodes data buffer in hex and writes resulting string to log.
        \param level Logging level.
        \param data Buffer.
        \param size Buffer size.
    */
    void dump(LogLevel level, const void *data, size_t size) const;
    /*!
        \brief Returns `true` if trace level is enabled for this logger.
    */
    bool isTraceEnabled() const;
    /*!
        \brief Returns `true` if info level is enabled for this logger.
    */
    bool isInfoEnabled() const;
    /*!
        \brief Returns `true` if warning level is enabled for this logger.
    */
    bool isWarnEnabled() const;
    /*!
        \brief Returns `true` if error level is enabled for this logger.
    */
    bool isErrorEnabled() const;
    /*!
        \brief Returns `true` if specified level is enabled for this logger.
        \param level Logging level.
    */
    bool isLevelEnabled(LogLevel level) const;
    /*!
        \brief Returns category name set for this logger.
    */
    const char* name() const;
    /*!
        \brief Generates log message.
        \param fmt Format string.

        This method uses default logging level (\ref DEFAULT_LEVEL).
    */
    void operator()(const char *fmt, ...) const __attribute__((format(printf, 2, 3)));
    /*!
        \brief Generates log message.
        \param level Logging level.
        \param fmt Format string.
    */
    void operator()(LogLevel level, const char *fmt, ...) const __attribute__((format(printf, 3, 4)));

private:
    const char *name_; // Category name

    void log(LogLevel level, const char *fmt, va_list args) const;
};

/*!
    \brief Log manager.

    Singleton class maintaining global list of registered log handlers. Log manager takes care of
    the necessary system callbacks and forwards generated logging output to registered log handlers.
*/
class LogManager {
public:
    /*!
        \brief Registers log handler globally.
        \param logger Handler instance.

        Note that this method doesn't affect ownership over the handler object.
    */
    void addHandler(LogHandler *handler);
    /*!
        \brief Unregisters log handler.
        \param logger Handler instance.
    */
    void removeHandler(LogHandler *handler);
    /*!
        \brief Returns log manager's instance.
    */
    static LogManager* instance();

private:
    std::vector<LogHandler*> handlers_;

    // This class is instantiated via instance() method
    LogManager() = default;

    // System callbacks
    static void logMessage(const char *msg, int level, const char *category, const LogAttributes *attr, void *reserved);
    static void logWrite(const char *data, size_t size, int level, const char *category, void *reserved);
    static int logEnabled(int level, const char *category, void *reserved);
};

/*!
    \brief Default logger instance.
*/
extern const Logger Log;

} // namespace spark

// spark::LogHandler
inline void spark::LogHandler::message(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
    if (level >= categoryLevel(category)) {
        logMessage(msg, level, category, attr);
    }
}

inline void spark::LogHandler::write(const char *data, size_t size, LogLevel level, const char *category) {
    if (level >= categoryLevel(category)) {
        write(data, size);
    }
}

inline void spark::LogHandler::write(const char *data, size_t size) {
    // Default implementation does nothing
}

inline void spark::LogHandler::write(const char *str) {
    write(str, strlen(str));
}

inline LogLevel spark::LogHandler::defaultLevel() const {
    return level_;
}

inline const char* spark::LogHandler::levelName(LogLevel level) {
    return log_level_name(level, nullptr);
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Stream &stream, LogLevel level, const Filters &filters) :
        LogHandler(level, filters),
        stream_(&stream) {
}

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline spark::StreamLogHandler::Stream* spark::StreamLogHandler::stream() const {
    return stream_;
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
}

inline void spark::Logger::trace(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_TRACE, fmt, args);
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_INFO, fmt, args);
    va_end(args);
}

inline void spark::Logger::warn(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_WARN, fmt, args);
    va_end(args);
}

inline void spark::Logger::error(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_ERROR, fmt, args);
    va_end(args);
}

inline void spark::Logger::printf(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log_printf_v(DEFAULT_LEVEL, name_, nullptr, fmt, args);
    va_end(args);
}

inline void spark::Logger::printf(LogLevel level, const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log_printf_v(level, name_, nullptr, fmt, args);
    va_end(args);
}

inline void spark::Logger::print(const char *str) const {
    print(DEFAULT_LEVEL, str);
}

inline void spark::Logger::print(LogLevel level, const char *str) const {
    write(level, str, strlen(str));
}

inline void spark::Logger::write(const char *data, size_t size) const {
    write(DEFAULT_LEVEL, data, size);
}

inline void spark::Logger::write(LogLevel level, const char *data, size_t size) const {
    if (data) {
        log_write(level, name_, data, size, nullptr);
    }
}

inline void spark::Logger::dump(const void *data, size_t size) const {
    dump(DEFAULT_LEVEL, data, size);
}

inline void spark::Logger::dump(LogLevel level, const void *data, size_t size) const {
    if (data) {
        log_dump(level, name_, data, size, 0, nullptr);
    }
}

inline bool spark::Logger::isTraceEnabled() const {
    return isLevelEnabled(LOG_LEVEL_TRACE);
}

inline bool spark::Logger::isInfoEnabled() const {
    return isLevelEnabled(LOG_LEVEL_INFO);
}

inline bool spark::Logger::isWarnEnabled() const {
    return isLevelEnabled(LOG_LEVEL_WARN);
}

inline bool spark::Logger::isErrorEnabled() const {
    return isLevelEnabled(LOG_LEVEL_ERROR);
}

inline bool spark::Logger::isLevelEnabled(LogLevel level) const {
    return log_enabled(level, name_, nullptr);
}

inline const char* spark::Logger::name() const {
    return name_;
}

inline void spark::Logger::operator()(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(DEFAULT_LEVEL, fmt, args);
    va_end(args);
}

inline void spark::Logger::operator()(LogLevel level, const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(level, fmt, args);
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr = { sizeof(LogAttributes) };
    log_message_v(level, name_, &attr, nullptr, fmt, args);
}

#endif // SPARK_WIRING_LOGGING_H
